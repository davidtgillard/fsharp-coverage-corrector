/// <summary>
///  Provides a function to combine the code coverage information of an F# package
/// from classes autogenerated at runtime with classes defined at runtime. 
/// </summary>
[<AutoOpen>]
module FSharpCoverageCorrector.Core.Corrections.AutogeneratedClasses

open FSharpCoverageCorrector.Core
open FSharpCoverageCorrector.Core.Utils
open System.Text.RegularExpressions

/// A group of methods autogenerated from the same source.
type private MethodAutoGeneratedGroup =
  private {
    sourceInfo_: ClassSourceInfo
    className_: string
    methodOfClass_: Method
    autoGeneratedClasses_: Class list
  }
  
  /// The source info, if available.
  member this.SourceInfo = this.sourceInfo_
  /// The name of the original class.
  member this.ClassName = this.className_
  /// The name of the original method.
  member this.MethodOfClass = this.methodOfClass_
  /// the autogenerated classes.
  member this.AutoGeneratedClasses = this.autoGeneratedClasses_
  
  /// Creates a new MethodAutoGeneratedGroup.
  /// Throws exception if autoGeneratedClasses is empty or not all classes share the same SourceInfo.
  static member Create(className, methodOfClass, autoGeneratedClasses: Class list) =
    if List.isEmpty autoGeneratedClasses then
      invalidArg (nameof autoGeneratedClasses) $"At least one autogenerated classes must be provided for method {methodOfClass} belonging to class {className}."
    // else
    let sourceInfos =
      autoGeneratedClasses
      |> List.map (fun agc -> agc.SourceInfo)
      |> List.distinct
    if List.length sourceInfos > 1 then
      invalidArg (nameof autoGeneratedClasses) $"Autogenerated classes provided for method {methodOfClass} belonging to class {className} do not share a single SourceInfo."
    { sourceInfo_ = sourceInfos.Head
      className_ = className
      methodOfClass_ = methodOfClass
      autoGeneratedClasses_ = autoGeneratedClasses }
  
  /// The line number extents of the group.
  member this.LineNumberExtents =
    let allLineNumbers = (this.AutoGeneratedClasses |> List.collect (fun c -> c.Lines)) @ this.MethodOfClass.Lines
                         |> List.map (fun l -> l.Number)
    List.min allLineNumbers, List.max allLineNumbers

/// Given a package, finds and groups all autogenerated classes.
let private groupAutoGeneratedClasses (pkg: Package) =
  
  // attempts to find the class in origClasses with the given className.
  // If unsuccessful, will then try to find a nested class with the same name as className, (className/className),
  // as can occur in the case where the class is in a module with the same name.
  let tryFindOrigClass (className:string) (methodName: string) (origClasses: Class list) =
    // see if we found a class with the same name as className that also has a method with the same name as methodName
    let origClassOpt = origClasses |> List.tryFind (fun c -> c.Name = className &&
                                                             List.contains methodName (c.Methods |> List.map (fun m -> m.Name)))
    match origClassOpt with
    | Some oc -> Some oc
    | None -> // if not found, try to find a class with the name className/className, that has a method by the name methodName
              let nestedName = className + "/" + Array.last (className.Split("."))
              origClasses |> List.tryFind (fun c -> c.Name = nestedName &&
                                                    (List.exists (fun (m: Method) -> m.Name = methodName) c.Methods))
              
  let autoGenClassRegexp = Regex(@"^.*/.*@[[1-9][0-9]*(-[1-9][0-9]*){0,1}$") // the pattern used to search for autogenerated classes
  // partition the autogenerated classes from the original classes
  let autoGenClasses, origClasses = pkg.Classes
                                    |> List.partition (fun c -> autoGenClassRegexp.IsMatch c.Name)
  // create 'groups' of autogenerated classes, of the form (className, methodName, classes)
  let autoGenGroups = autoGenClasses
                      |> List.groupBy (fun c ->
                                         let split = c.Name.Split [|'/'; '@'|]
                                         split[0], split[1])
                      |> List.map (fun ((className, methodName), classes) -> className, methodName, classes)
  // partition the autogenerated groups into those for which a corresponding original method has been found, and those for which no method was found
  let found, notFound = autoGenGroups
                        |> List.map (fun (className, methodName, agClasses) -> 
                                       className, methodName, agClasses, (tryFindOrigClass className methodName origClasses))
                        |> partitionMap 
                           (fun (_, _, _, origClassOpt) -> origClassOpt.IsSome) // partition on the basis of origClassOpt.IsSome
                           (fun (_, methodName, agClasses, origClassOpt) -> methodName, agClasses, origClassOpt.Value) // map all the groups with an original class to (methodName, agClasses, origClass)
                           (fun (_, _, agClasses, _) -> agClasses) // map all those groups without an original class to agClasses
                             
  // create the MethodAutoGeneratedGroups for those which are found
  let foundGroups = found
                    |> List.map (fun (methodName, agClasses, origClass) ->
                        let origMethodOpt = (origClass.Methods |> List.tryFind (fun m -> m.Name = methodName))
                        let origMethod = origMethodOpt.Value
                        MethodAutoGeneratedGroup.Create(origClass.Name, origMethod, agClasses)
                      )
        
  // for each autogenerated group tht hasn't been found, try to find the original method by looking up line extents
  let results = (seq {
    for autoGenClasses in notFound do
      let firstClassWithLinesOpt =
        autoGenClasses
        |> List.tryFind (fun cls -> cls.Lines.Length > 0)
      match firstClassWithLinesOpt with
      | Some firstClassWithLines ->
          if firstClassWithLines.Lines.Length > 0 then
            let firstLine = firstClassWithLines.Lines[0] // we know that autoGenClasses is not empty, and Lines is also not empty, so this is safe
            let lineFoundOpt = foundGroups
                               |> List.tryFind (fun grp -> let minLine, maxLine = grp.LineNumberExtents
                                                           grp.SourceInfo.Filename = firstClassWithLines.Filename &&
                                                           firstLine.Number >= minLine &&
                                                           firstLine.Number <= maxLine)
            match lineFoundOpt with
            | Some grp ->
              yield Ok (MethodAutoGeneratedGroup.Create(grp.ClassName, grp.MethodOfClass, autoGenClasses @ grp.AutoGeneratedClasses))
            | None -> 
              let autogeneratedClassNames = autoGenClasses |> List.map (fun c -> c.Name) |> String.concat "; "
              // todo: use a special error type
              yield Error $"No matching original method found for autogenerated classes: {autogeneratedClassNames}"
      | None -> ()
  } |> Seq.toList)
  
  let updatedAutoGenGroups = results |> unwrapOks
  let failedToCorrect = results |> unwrapErrors
  
  // concat the update groups and the found groups, throwing away any found groups that were updated
  let updatedAndFoundGroups = (updatedAutoGenGroups @ foundGroups) |> List.distinctBy (fun c -> c.ClassName, c.MethodOfClass)
  updatedAndFoundGroups, failedToCorrect
  
/// Given a group and a package, corrects the package, combining the autogenerated classes with
/// the original method and removing the autogenerated classes in the group.
let private correctMethod (grp: MethodAutoGeneratedGroup) (package: Package) =
  // merge two lines.
  let mergeSingleLines (l1: Line) (l2: Line) =
    if l1.Number <> l2.Number then
      failwith "expected numbers to be equal"
    if l1.Contents <> l2.Contents then
      failwith "expected contents to be equal"
    let hits = l1.Hits + l2.Hits
    let conditions = l1.Conditions
                     |> List.map (fun c1 -> 
                                   let c2Opt = l2.Conditions |> List.tryFind (fun cond -> cond.Number = c1.Number)
                                   match c2Opt with
                                   | Some c2 -> if c1.Coverage > c2.Coverage then c1 else c2
                                   | None -> c1)
    { Number = l1.Number
      Hits = hits
      Conditions = conditions
      Contents = l1.Contents }
  
  // merge two lists of lines.
  let mergeLines (lines1: Line list) (lines2: Line list) =
    let notOnlyLine2 = List.fold
                         (fun updated l1 ->
                                    let l2Opt = lines2 |> List.tryFind (fun l -> l.Number = l1.Number)
                                    match l2Opt with
                                    | Some l2 -> (mergeSingleLines l1 l2)::updated
                                    | None -> l1::updated )
                         []
                         lines1
    let onlyLine2 = lines2 |> List.filter (fun l2 ->  notOnlyLine2
                                                      |> List.tryFind (fun l -> l.Number = l2.Number)
                                                      |> Option.isNone)
    notOnlyLine2 @ onlyLine2 |> List.sortBy (fun l -> l.Number)
  
  // update the lines by merging
  let updatedLines = List.fold (fun lines (ac: Class) -> mergeLines lines ac.Lines)
                                grp.MethodOfClass.Lines
                                grp.AutoGeneratedClasses
  let updatedMethod = { grp.MethodOfClass with Lines = updatedLines }
  let origClass = package.Classes |> List.find (fun c -> c.Name = grp.ClassName)
  // replace the methods in the original class
  let updatedClass =
    let methods = replace (fun (m1: Method) (m2: Method) -> m1.Name = m2.Name) updatedMethod origClass.Methods
    match origClass.SourceInfo with
    | Contents (sf, rs) -> Class.Create(origClass.Name, sf, rs, methods, origClass.NonMethodLines)
    | NoContents _-> Class.Create(origClass.Name, origClass.Filename, methods, origClass.NonMethodLines)
  let inAutoGenClasses (c: Class) = (List.tryFind (fun (agc: Class) -> c.Name = agc.Name) grp.AutoGeneratedClasses).IsSome // function to determine if a class is in the list of autogenerated classes
  // update the list of classes to replace the original class with the updated class, and exclude auto-generated classes
  let updatedClasses = package.Classes
                      |> replace (fun c1 c2 -> c1.Name = c2.Name) updatedClass // replace the original class with the updated class
                      |> List.filter (fun c -> not (inAutoGenClasses c))
  // update the package with the updated classes
  let updatedPkg = { package with Classes=updatedClasses }
  updatedPkg

/// <summary>
/// Given a package, correct any autogenerated classes created at runtime within it.
/// 'Correct' in this context means merge the coverage for each autogenerated class into the method of origin, and remove the autogenerated class.
/// </summary>
/// <param name="package">The package to correct.</param>
/// <result>The corrected package and a list of errors of classes that could not be corrected.</result>
let correctAutogeneratedClasses (package: Package) =
  let autogeneratedGroups, errors = groupAutoGeneratedClasses package
  // update the package by correcting each method with the information extracted from the classes generated automatically at runtime corresponding to the method
  let correctedPackage =
    List.fold (fun pkg group -> correctMethod group pkg)
      package
      autogeneratedGroups
  correctedPackage, errors  