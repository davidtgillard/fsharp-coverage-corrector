open System
open System.Collections.Generic
open System.Reflection
open Argu
open FSharpLint.Framework.Ast
open FSharpCoverageCorrector.Core
open FSharpCoverageCorrector.Core.Corrections
open FSharpCoverageCorrector.IO.Cobertura
open FSharpLint.Framework.ParseFile
open Microsoft.FSharp.Core
  
type CliArguments =
  | [<ExactlyOnce>] Coverage_File of coverage_file: string
  | [<Mandatory>] Project_File of project_file: string
  | [<ExactlyOnce>] Output_File of output_file: string
  
  with
    interface IArgParserTemplate with
        member s.Usage =
            match s with
            | Coverage_File _ -> "The input coverage file, in Cobertura XML format."
            | Project_File _ -> "An project (.fsproj) file."
            | Output_File _ -> "The output file, in XML format."

let programName = Assembly.GetExecutingAssembly().GetName().Name
  
let errorHandler = ProcessExiter(colorizer = function ErrorCode.HelpText -> None | _ -> Some ConsoleColor.Red)
let parser = ArgumentParser.Create<CliArguments>(programName=programName, errorHandler = errorHandler)

let printErrorAndExit message =
  eprintfn $"Error: %s{parser.PrintUsage(message)}"
  exit 1
      
let parseResult = parser.Parse(inputs = Environment.GetCommandLineArgs()[1..])

let toolsPath = Ionide.ProjInfo.Init.init()
let projectLoadResults = loadProjectFiles (parseResult.GetResults Project_File) toolsPath |> Seq.toList
 
// obtain the file parse information from loading the projects
let fileParseInfo = projectLoadResults
                     |> List.filter (fun result -> match result with | Ok _ -> true | Error _ -> false) // filter out any Errors
                     |> List.map (fun result -> match result with | Ok x -> x | Error _ -> failwith "")// retrieve the Oks
                     |> List.concat // cat them all
                     
// obtain the errors
let loadErrors = projectLoadResults
                 |> List.filter (fun result -> match result with | Ok _ -> false | Error _ -> true) // filter out any Oks
                 |> List.map (fun result -> match result with | Ok _ -> failwith "" | Error x -> x) // retrieve the Errors

// todo: clean this up
if not (List.isEmpty loadErrors) then
  let errorMessages = List<string>()
  errorMessages.Add $"Error occurred loading project information"
  for err in loadErrors do               
     match err with
     | ProjectLoadError.ProjectInfoError e -> errorMessages.Add $"\tAn error occurred loading project information: {e}"
     | ProjectLoadError.ParseFileError failureList ->
         let errMsg = failureList |> List.fold
                                        (fun str failure ->
                                           str + Environment.NewLine +
                                           match failure with
                                           | ParseFileFailure.AbortedTypeCheck -> "\t\tAborted type check"
                                           | ParseFileFailure.FailedToParseFile parseFailures ->
                                             parseFailures
                                             |> Array.map (fun f -> $"\t\tFailed to parse file ${f.FileName}: ${f.Message}")
                                             |> String.concat Environment.NewLine
                                        )
                                        "\tError parsing source files: "
         errorMessages.Add errMsg
     // print the final error
     printErrorAndExit (String.Join('\n', errorMessages.ToArray()))
// else

let anrps = loadAstNodeRuleParamsFromProject fileParseInfo

match readPackagesFromCoberturaFile fileParseInfo anrps (parseResult.GetResult Coverage_File) with
| Error ex ->
  let errMsg = $"Error reading data from input file: {ex.Message}{Environment.NewLine}{ex.ToString()}{Environment.NewLine}"
  printErrorAndExit errMsg
| Ok packages ->
  // apply the corrections
  let correctedPackages = packages
                          |> List.map correctAutogeneratedClasses
                          |> List.map correctBranchCoverage
  let xml = generateXml correctedPackages
  try
    xml.Save(parseResult.GetResult Output_File)
  with
  | ex -> let errMsg = $"Error writing data to {Output_File}: {ex.Message}{Environment.NewLine}{ex.ToString()}{Environment.NewLine}"
          printErrorAndExit errMsg

// finally, if successful, return ok exit code
Environment.ExitCode <- 0