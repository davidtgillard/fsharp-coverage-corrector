open System
open System.Reflection
open Argu
open FSharpLint.Framework.Ast
open FSharpCoverageCorrector.Core
open FSharpCoverageCorrector.Core.Corrections
open FSharpCoverageCorrector.IO.Cobertura
open FSharpLint.Framework.ParseFile
  
type CliArguments =
  | [<ExactlyOnce>] Output_File of string
  | [<ExactlyOnce>] Project_File of string
  | [<MainCommand; ExactlyOnce; Last>] Input_File of input_file: string
  
  with
    interface IArgParserTemplate with
        member s.Usage =
            match s with
            | Output_File _ -> "The output file, in XML format."
            | Project_File _ -> "The project (.fsproj) file."
            | Input_File _ -> "The input file, in Cobertura XML format."

let programName = Assembly.GetExecutingAssembly().GetName().Name
let parser = ArgumentParser.Create<CliArguments>(programName=programName)

let printErrorAndExit message =
  eprintfn $"Error: %s{parser.PrintUsage(message)}"
  exit 1
    
if Environment.GetCommandLineArgs().Length = 1 then
  printErrorAndExit "No input file argument provided."
  
let parseResult = parser.Parse(inputs = Environment.GetCommandLineArgs()[1..], raiseOnUsage=true)

let toolsPath = Ionide.ProjInfo.Init.init()
let projectFilesInfo = match loadProjectFiles (parseResult.GetResult Project_File) toolsPath with
                        | Ok fileParseInfoList -> fileParseInfoList
                        | Error err ->
                          let errMsg = match err with
                                        | ProjectLoadError.ProjectInfoError e -> $"An error occurred loading project information: {e}"
                                        | ProjectLoadError.ParseFileError failureList ->
                                          failureList |> List.fold (fun str failure ->
                                                            str + Environment.NewLine +
                                                            match failure with
                                                            | ParseFileFailure.AbortedTypeCheck -> "Aborted type check"
                                                            | ParseFileFailure.FailedToParseFile parseFailures ->
                                                              parseFailures
                                                              |> Array.map (fun f -> $"Failed to parse file ${f.FileName}: ${f.Message}")
                                                              |> String.concat Environment.NewLine
                                                            )
                                                            "Error parsing source files: "
                          printErrorAndExit errMsg

let anrps = loadAstNodeRuleParamsFromProject projectFilesInfo

match readPackagesFromCoberturaFile projectFilesInfo anrps (parseResult.GetResult Input_File) with
| Error ex ->
  let errMsg = $"Error reading data from input file: {ex.Message}{Environment.NewLine}{ex.ToString()}{Environment.NewLine}"
  printErrorAndExit errMsg
| Ok packages ->
  // apply the corrections
  let correctedPackages = packages
                          |> List.map correctAutogeneratedClasses
                          |> List.map correctBranchCoverage
  let xml = generateXml correctedPackages
  try
    xml.Save(parseResult.GetResult Output_File)
  with
  | ex -> let errMsg = $"Error writing data to {Output_File}: {ex.Message}{Environment.NewLine}{ex.ToString()}{Environment.NewLine}"
          printErrorAndExit errMsg

// finally, if successful, return ok exit code
Environment.ExitCode <- 0