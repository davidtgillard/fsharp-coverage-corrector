open System
open System.Reflection
open Argu
open FSharpLint.Framework.Ast
open FSharpCoverageCorrector.Core
open FSharpCoverageCorrector.Core.Corrections
open FSharpCoverageCorrector.IO.Cobertura
open FSharpLint.Framework.ParseFile
open Microsoft.FSharp.Core
  
type CliArguments =
  | [<ExactlyOnce>] Coverage_File of coverage_file: string
  | [<Mandatory>] Project_File of project_file: string
  | [<ExactlyOnce>] Output_File of output_file: string
  
  with
    interface IArgParserTemplate with
        member s.Usage =
            match s with
            | Coverage_File _ -> "The input coverage file, in Cobertura XML format."
            | Project_File _ -> "An project (.fsproj) file."
            | Output_File _ -> "The output file, in XML format."

let programName = Assembly.GetExecutingAssembly().GetName().Name
  
let errorHandler = ProcessExiter(colorizer = function ErrorCode.HelpText -> None | _ -> Some ConsoleColor.Red)
let parser = ArgumentParser.Create<CliArguments>(programName=programName, errorHandler = errorHandler)

let printErrorAndExit message =
  eprintfn $"Error: %s{parser.PrintUsage(message)}"
  exit 1
      
let parseResult = parser.Parse(inputs = Environment.GetCommandLineArgs()[1..])

let toolsPath = Ionide.ProjInfo.Init.init()
let projectLoadResults = loadProjectFiles (parseResult.GetResults Project_File) toolsPath

let fileParseInfo = projectLoadResults
                     |> Seq.filter (fun result -> match result with | Ok _ -> true | Error _ -> false)
                     |> Seq.map (fun result -> match result with | Ok x -> x | Error _ -> failwith "")
                     |> Seq.concat
                     |> Seq.toList
                     
let loadErrors = projectLoadResults
                 |> Seq.filter (fun result -> match result with | Ok _ -> false | Error _ -> true)
                 |> Seq.map (fun result -> match result with | Ok _ -> failwith "" | Error x -> x)
                 |> Seq.toList

// todo: clean this up
if not (List.isEmpty loadErrors) then
  for err in loadErrors do               
     let errMsg = match err with
                  | ProjectLoadError.ProjectInfoError e -> $"An error occurred loading project information: {e}"
                  | ProjectLoadError.ParseFileError failureList ->
                    failureList |> List.fold (fun str failure ->
                                      str + Environment.NewLine +
                                      match failure with
                                      | ParseFileFailure.AbortedTypeCheck -> "Aborted type check"
                                      | ParseFileFailure.FailedToParseFile parseFailures ->
                                        parseFailures
                                        |> Array.map (fun f -> $"Failed to parse file ${f.FileName}: ${f.Message}")
                                        |> String.concat Environment.NewLine
                                      )
                                      "Error parsing source files: "
      printErrorAndExit errMsg

let anrps = loadAstNodeRuleParamsFromProject projectFilesInfo

match readPackagesFromCoberturaFile projectFilesInfo anrps (parseResult.GetResult Coverage_File) with
| Error ex ->
  let errMsg = $"Error reading data from input file: {ex.Message}{Environment.NewLine}{ex.ToString()}{Environment.NewLine}"
  printErrorAndExit errMsg
| Ok packages ->
  // apply the corrections
  let correctedPackages = packages
                          |> List.map correctAutogeneratedClasses
                          |> List.map correctBranchCoverage
  let xml = generateXml correctedPackages
  try
    xml.Save(parseResult.GetResult Output_File)
  with
  | ex -> let errMsg = $"Error writing data to {Output_File}: {ex.Message}{Environment.NewLine}{ex.ToString()}{Environment.NewLine}"
          printErrorAndExit errMsg

// finally, if successful, return ok exit code
Environment.ExitCode <- 0